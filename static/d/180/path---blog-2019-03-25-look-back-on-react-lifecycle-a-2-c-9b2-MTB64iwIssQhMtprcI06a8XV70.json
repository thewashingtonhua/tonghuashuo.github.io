{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>写在前面</h2>\n<p>React 组件的生命周期，相信大家都非常熟悉了，无非那么几个函数，官方文档已经写得非常清楚了。</p>\n<p>（那还有什么好说的？这么基础的东西，合上！）</p>\n<p>一般我们所讨论的，都是单个组件的生命周期。如果是父子组件呢？各个周期又是什么样的？异步路由的情况呢？前阵子新出的 Hooks 呢？有几个人敢站出来说我全知道的？（反正我是不敢）</p>\n<p>刚好也是最近遇到一些关于生命周期的问题，项目中涉及到大量的异步操作，需要清楚地知道各部分的执行顺序，正好借此机会整理一下。</p>\n<h2>那么我们就来做个实验吧</h2>\n<p>为了一探究竟，我写了一个 <a href=\"https://tonghuashuo.github.io/react-lifecycle\">Demo</a> 来模拟一些常见的用例，主要研究下面这几个问题：</p>\n<ul>\n<li>父子组件各阶段的执行顺序</li>\n<li>异步路由对加载顺序是否有影响</li>\n<li>Hooks 的生命周期</li>\n</ul>\n<h2>TL,DR;</h2>\n<p>我知道大家时间都很宝贵，赶时间的朋友可以直接看结论，细节我们放到后面讲：</p>\n<ol>\n<li>\n<p>父组件 <code class=\"gatsby-code-text\">render</code> 时创建子组件</p>\n<ol>\n<li>同步路由，子组件 <code class=\"gatsby-code-text\">didMount</code> 之后，父路由才算 <code class=\"gatsby-code-text\">didMount</code>。</li>\n<li>异步路由，父路自己先 <code class=\"gatsby-code-text\">didMount</code>，然后才会开始创建子路由的内容。</li>\n<li>Hooks 的加载过程并无例外，但是 Effect 会在父组件 <code class=\"gatsby-code-text\">didMount</code> / <code class=\"gatsby-code-text\">didUpdate</code> 之后执行。</li>\n</ol>\n</li>\n<li>\n<p>父组件更新导致子组件更新时：</p>\n<ol>\n<li>子组件 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code> 之后，并不是直接进入到自身的 <code class=\"gatsby-code-text\">didUpdate</code>，而是先触发父组件的 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code>。</li>\n<li>上述过程之后，子组件先 <code class=\"gatsby-code-text\">didUpdate</code>，然后才是父组件 <code class=\"gatsby-code-text\">didUpdate</code>。</li>\n</ol>\n</li>\n<li>\n<p>组件切换的具体过程：</p>\n<ol>\n<li>父组件触发更新过程，执行 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 和 <code class=\"gatsby-code-text\">render</code>.</li>\n<li>在父组件的 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code> 之前调用新子组件的 render.</li>\n<li>在父组件的 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code> 之后，<code class=\"gatsby-code-text\">componentDidUpdate</code> 之前，卸载旧的子组件。</li>\n<li>如果新组件使用了 useEffect，在父组件 <code class=\"gatsby-code-text\">componentDidUpdate</code> 之后执行 Effect。</li>\n</ol>\n</li>\n</ol>\n<h2>同步路由</h2>\n<p>子组件先 didMount，父组件再 didMount</p>\n<h2>异步路由</h2>\n<p>父路由先 didMount，子路由再 didMount</p>\n<h2>Hooks</h2>\n<p>确切地说，Hooks 并不是一种新的组件写法，它只是一种代码复用的方式。这里讨论的本体其实是函数式组件。</p>\n<p>在 Hooks 之前，函数式组件是没有 state 的概念的，因此也就不存在生命周期一说，调用的时候只管执行就完了。但伴随着 Hooks 的到来，函数式组件也拥有了 state，因此讨论函数式组件的生命周期也便成了新的研究对象。</p>\n<blockquote>\n<p>严格说来，函数式组件本质是函数，「函数」是没有生命周期的，Hooks 的出现也并没有改变这一原理。这里我们讨论的是「组件」，「组件」是可以有生命周期的。</p>\n</blockquote>\n<p>函数式组件的生命周期和 Class 不太一样，它没有生命周期钩子函数，只管执行函数。</p>\n<p>具体到 Hooks 相关的部分，主要就是 useEffect、useLayout 的调用时机的问题。</p>","frontmatter":{"title":"说起 React 的生命周期，你或许还不知道……","description":"事情好像没那么简单","cover":{"publicURL":"/static/react-lifecycle-0edf69056144aaf512a28d0670b53b57.jpg"},"tags":["react","lifecycle"],"series":"","draft":true},"fields":{"id":"look-back-on-react-lifecycle","date":"2019-03-24T16:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/03/25/look-back-on-react-lifecycle"}}
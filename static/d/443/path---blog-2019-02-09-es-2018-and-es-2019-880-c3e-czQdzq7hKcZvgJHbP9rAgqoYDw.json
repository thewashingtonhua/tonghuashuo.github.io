{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>标准这事儿吧……</h2>\n<p>ES 2019（ES 10）标准于年前正式发布，借此机会，我们来看看都有哪些特性有幸转正吧。顺带把 ES 2018 的内容也补一下。</p>\n<p>ECMAScript 标准的制定过程，自 2015 年大改，至今已经是第 5 个年头了，想必大家都心里有数了。与 Java 等语言不同，JS 并非先制定标准再开始使用，恰恰相反，是大家先用着，觉得合适的，才收录进标准。标准的存在更像是一个“年度优秀特性合集”。对绝大部分开发者来说，一项特性进没进标准不重要，Babel 支不支持才重要。标准你随便写，不用 Babel 算我输。</p>\n<p>那么接下来，我们就来看看 2018 和 2019 两个年度的大合集都有些啥吧。</p>\n<h2>ES2018（ES9）</h2>\n<h3>1）异步迭代器（Asynchronous Iteration）</h3>\n<p>总有那么些时候，我们会想要同步执行一些异步的操作，比如下面这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">const</span> actions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>利用 <code class=\"gatsby-code-text\">async / await</code> 语法，我们可以很轻松的做到这点。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">process</span> <span class=\"token punctuation\">(</span>actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> action <span class=\"token keyword\">of</span> actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面的写法，会按顺序执行 <code class=\"gatsby-code-text\">asyncFunc</code>，上一个结束之后才会开始下一个，每次得到的 <code class=\"gatsby-code-text\">action</code> 都是一个异步操作本身（比如这里是一个 Promise 对象）。</p>\n<p>ES 2018 为我们提供了一种新的方式，在前面代码的基础之上，让每次得到的 <code class=\"gatsby-code-text\">action</code> 直接是异步操作完成之后的结果（比如这里是 Promise 被 resolve 之后的结果）。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">process</span> <span class=\"token punctuation\">(</span>actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> action <span class=\"token keyword\">of</span> actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>2）“其余属性”和“扩展运算符” 开始适用于对象</h3>\n<p>这是一个从 ES 2015 开始就被广泛使用的特性，只不过 ES 2015 的标准只支持用于数组，从 ES 2018 开始也支持对象了。</p>\n<p>事实上 Map、Set、String 同样支持 <code class=\"gatsby-code-text\">...</code>，但具体是哪个版本引入的我还真没数。（反正我已经用了很久了，不管了）</p>\n<h3>3）Promise.finally</h3>\n<p>正如它的名字，finally。这也是个用了好久终于进标准的特性。</p>\n<p>在处理 Promise 的返回时，我们经常会遇到这样的情况：无论结果状态是 resolved 还是 rejected，都执行一样的逻辑。</p>\n<p>早先遇到这种情况，我们不得不在 <code class=\"gatsby-code-text\">then()</code> 和 <code class=\"gatsby-code-text\">catch()</code> 里都写一遍，现在可以一次性写在 <code class=\"gatsby-code-text\">finally()</code> 里。一个 <code class=\"gatsby-code-text\">finally()</code> 就等价于一组回调函数相同的 <code class=\"gatsby-code-text\">then()</code> 和 <code class=\"gatsby-code-text\">catch()</code>。</p>\n<p>虽然名字叫“最终”，但并不代表这是 Promise 执行的终点。<code class=\"gatsby-code-text\">finally()</code> 后面还可以继续跟 <code class=\"gatsby-code-text\">then()</code> 和 <code class=\"gatsby-code-text\">catch()</code>，无限跟。</p>","frontmatter":{"title":"你可能已经知道的 ES 2018 和 2019","description":"跟上时代的步伐","cover":{"publicURL":"/static/es2019-5646b4878e533cd7c725ce4c17984071.jpg"},"tags":["ecmascript","2018","2019"],"series":null,"draft":true},"fields":{"id":"es2018-and-es2019","date":"2019-02-08T16:00:00.000Z"}}},"pageContext":{"slug":"/blog/2019/02/09/es2018-and-es2019"}}
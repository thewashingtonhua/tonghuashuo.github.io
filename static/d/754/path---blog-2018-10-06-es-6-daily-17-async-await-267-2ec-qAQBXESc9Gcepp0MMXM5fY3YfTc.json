{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>又一个异步解决方案</h2>\n<p>ES2015 在异步方面可谓是做足了贡献。之前我们已经介绍过了 Promise，一种可以让我们把异步操作写成链式调用的语法；就在上一篇，我们又介绍了 Generator，一种可以把异步操作同步化的语法。所以这个“异步/等待”又是什么新玩法？</p>\n<h2>只是个语法糖</h2>\n<p>时至今日，大家对 <code class=\"gatsby-code-text\">async</code> / <code class=\"gatsby-code-text\">await</code> 应该已经很听说过很多次了，算是 ES2015 以来被知道最多的特性之一。即便日常工作中没有用到，也都有所耳闻。</p>\n<p>和 Generator 一样， <code class=\"gatsby-code-text\">async</code> / <code class=\"gatsby-code-text\">await</code> 也是一种可以把异步操作同步化的语法。确切的说，它并不是什么全新的东西，不过是 Generator 的语法糖：</p>\n<ul>\n<li>把 <code class=\"gatsby-code-text\">*</code> 替换成 <code class=\"gatsby-code-text\">async</code></li>\n<li>把 <code class=\"gatsby-code-text\">yield</code> 替换成 <code class=\"gatsby-code-text\">await</code></li>\n</ul>\n<p>结束。</p>\n<h2>不只是个语法糖</h2>\n<p>当然，能够单独作为一篇出来讲的，肯定不会只是语法糖这么简单，虽然语法看上去就这么简单。</p>\n<p>我们知道，执行 Generator 函数的结果是得到一个遍历器实例，需要手动调用 <code class=\"gatsby-code-text\">next()</code> 才能执行。async 函数内置了执行器，调用 async 函数就和调用普通函数一样，没有区别。</p>\n<p>从语义上讲，相比 <code class=\"gatsby-code-text\">*</code> 和 <code class=\"gatsby-code-text\">yield</code> ， <code class=\"gatsby-code-text\">async</code> / <code class=\"gatsby-code-text\">await</code> 更加的直观， <code class=\"gatsby-code-text\">async</code> 表示函数里有异步操作，但是，函数本身是同步的。 <code class=\"gatsby-code-text\">await</code> 表示等待右边紧跟的操作完成，再进入后续的流程，最终得到一个同步的执行流程。</p>\n<p>async 函数返回一个 Promise 对象，可以直接用 <code class=\"gatsby-code-text\">then()</code> 指定下一步的操作，相比 Generator 返回一个 Iterator 对象更方便。</p>\n<p>换个角度，async 函数也可以看作是把多个异步操作包装成一个 Promise， <code class=\"gatsby-code-text\">await</code> 就相当于内部的 <code class=\"gatsby-code-text\">then()</code> ，用于控制异步操作同步执行。和  <code class=\"gatsby-code-text\">Promise.all()</code> 也很类似，只不过内部的多个异步流程是按顺序执行的。</p>\n<h2>不，async 不一定是异步的</h2>\n<p>虽然 async 这个词本身表示异步（asynchronous的缩写），但 async 函数本身并不是异步的。是的，你没有看错，这个顶着异步名号的家伙，其实是个同步函数，真正的“异步”在它的肚子里。如果 async 函数的函数体里执行的全都是同步操作，那么它就和普通的函数没什么区别，只有当其中执行到异步的操作的时候，配合 await 才会发挥出真正的威力。</p>\n<h2>所以，要怎么用呢？</h2>\n<p>少废话，看东西。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">asyncFunc</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'called'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'async'</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'then'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sync'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// called</span>\n<span class=\"token comment\">// sync</span>\n<span class=\"token comment\">// async</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>在函数定义的最前面添加 <code class=\"gatsby-code-text\">async</code> 表示这是个 async 函数。</li>\n<li><code class=\"gatsby-code-text\">awiat</code> 只能在 <code class=\"gatsby-code-text\">async</code> 函数内部使用。</li>\n<li>async 函数本身是同步的，所以 \"called\" 会先打出来；直到遇到第一个 <code class=\"gatsby-code-text\">await</code> ，函数先返回，后面的流程全都视为异步。所以 \"async\" 会在 \"sync\" 之后打出。</li>\n<li><code class=\"gatsby-code-text\">await</code> 后面通常接一个异步操作，待执行完成后返回结果，再往下执行。当然 <code class=\"gatsby-code-text\">await</code> 后面也可以接一些原始类型，此时这就相当于是一个同步操作。但这并不影响 async 函数会在这之前先返回。</li>\n<li>async 函数的调用和普通函数一样。</li>\n<li>async 函数总是返回一个 Promise，如果函数内 <code class=\"gatsby-code-text\">return</code> 语句返回的不是 Promise，则会被包装秤一个立即 resolve 的 Promise对象。</li>\n<li>async 函数在遇到第一个 <code class=\"gatsby-code-text\">awiat</code> 时会先返回一次，交还程序的控制权给到父级，函数内的后续流程会继续异步执行，直到完成或出错，才正式返回一个 Promise。</li>\n</ul>\n<h2>async 函数的错误处理</h2>\n<p>async 函数的错误处理机制其实和 Promise 差不多，只不过一些细节上需要留意一下。</p>\n<p>async 函数里如果出现有 Promise 被 reject 的情况，无论代码中是否有 <code class=\"gatsby-code-text\">return</code> ，函数会立即返回一个被 reject 的 Promise，后续代码不会执行。如果希望异步操作出错不影响后续的逻辑，可以把异步操作嵌套在 <code class=\"gatsby-code-text\">try...catch</code> 里，如果异步操作本身就是 Promise，也可以用 Promise 的 <code class=\"gatsby-code-text\">catch()</code> 来处理。</p>\n<h2>实现一个自动执行器</h2>\n<p>我们已经知道 async 就是一个 Generator 加上自动执行器，Generator 我们已经知道了，自动执行又是怎么做到的呢？要解释清楚这个问题，还得看代码。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token comment\">// 通过参数传入一个 Generator</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">spawn</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">genF</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 获得 Generator 实例</span>\n    <span class=\"token keyword\">const</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">genF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// 内部函数，用于递归执行</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">nextF</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> next\n\n      <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 尝试获取 Generator 实例的下一状态</span>\n        next <span class=\"token operator\">=</span> <span class=\"token function\">nextF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\">// 出口</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\">// 如果还有后续，那么继续</span>\n      Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">e</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">throw</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 开始执行</span>\n    <span class=\"token function\">step</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2>小结</h2>\n<p>一句话概括：async 函数 === 自动执行器(Generator)。</p>\n<p>这个系列名为 ES6，也就是 ES2015，但 async/await 真正加入标准是在 ES2017，晚了 2 年。不过因为是语法糖的关系，主流环境早在这之前就已经给出了 Polyfill，Node.js 从 7.x 开始也已经正式支持了 <code class=\"gatsby-code-text\">async</code> / <code class=\"gatsby-code-text\">await</code> ，所以日常可以放心大胆直接用了。</p>\n<h2>该系列的其他文章</h2>\n<p>上一篇：<a href=\"/blog/2018/06/14/es6-daily-16-generator\">每天一点ES6(16)：Generator</a></p>\n<p>下一篇：<a href=\"/blog/2018/12/17/es6-daily-18-class\">每天一点ES6(18)：Class</a></p>","frontmatter":{"title":"每天一点ES6(17)：Async / Await","description":"异步？先等等！","cover":{"publicURL":"/static/es6daily-0950334fb8899f1006423341cbfeecb9.jpg"},"tags":["ecmascript","2015","es6","javascript","async","await","generator"],"series":"es6daily","draft":false},"fields":{"id":"es6-daily-17-async-await","date":"2018-10-05T16:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2018/10/06/es6-daily-17-async-await"}}
{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<p>在过去几年的工作中，我有幸把市面上主流的几种样式解决方案都尝试了一遍。但拥有太多的选择也会让人头疼，最终，你得选择一样，作为你的日常之选。</p>\n<p>我，选择了 SCSS。</p>\n<h1>为什么需要 CSS 处理器？</h1>\n<p>CSS 处理器诞生于 CSS 的刀耕火种年代，那时人们手把手一点一点写出每一行 CSS 的代码，什么变量复用、什么继承，都是不存在的。</p>\n<p>CSS 处理器的诞生，让人们不再需要直接编写 CSS，可以通过代码去生成 CSS 代码。我们可以定义变量来实现复用，可以更好地进行模块化，可以通过预置的函数更方便地控制字符串、数字、颜色等，可以自己编写函数来批量生成 CSS 代码。极大提高了开发者的生产效率。</p>\n<p>从工程的角度，提升效率是有助于提升收益的。</p>\n<h1>离开 CSS 处理器或许也可以？</h1>\n<p>CSS 处理器并不是一种新的语言，它只是一种用来生成 CSS 的工具，它最终的产物还是 CSS，浏览器能够支持的也只有 CSS。</p>\n<p>你当然可以不用任何工具直接编写 CSS，但既然有这么好用的工具在，我们又何必跟自己过不去呢？但如果你无论如何一定要这样，也不是不可以。事实上经过多年的实践，很多 CSS 处理器特有的功能，已经慢慢开始进入标准的 CSS。</p>\n<p>比如「变量」，<a href=\"https://www.w3.org/TR/css-variables-1/\">CSS 自定义变量</a> 已经是一个被广泛支持的属性了（除非你还需要支持 IE ……）。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/15230aaca66d6ba258b5cb0c19676bdc/5d6f6/caniuse-css-custome-properties.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 960px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 49.80299448384555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACVUlEQVQoz42S309SYRjHz7/Wn9DWynXRZRd1VRc1yy1LbHPJQnEDsRJdq2aYF9nSzImAggjxQ+QgHA5wgAOHA5mSJeX69ILNddPWxWff53l3zvN89zyPVMltUZQ3yKd8PS2mNyikAyg7Xmr5IAe1XUHqjMP6Lk0thlGM0hZxqxqnVopgVlLUi0mkkihSSK1TU7aoq5FTzW+j50LoSogDfYe2kT7jyJT5XE3SLImCokG3oKGFaZWjwkAYqZmYw0x6MKppQZxGI4NhZDDVVb6U1jCNPVrCTaMYEQ3DotFWL68XPglHUcyCcCdiXZgwqymkRktBWZ0h475Pw/uWzKgFbXGOyssp8tZBqr4lqmIMurpNWfysZMOYSpSSHEGXQ1SzIVQ1ihJbRw96kTTXGNNPLnJz4RzD9j5GBEP2CwxNXOKe7TwPHH1kAvNE5u1sjveTHLmF99kgkYiHWNFLbMVNynqXmPye2YUBJPnpKG+eD2Hxj3Jl+TpXl29wefkat9cGcATHsW9YCbke8spjYe7FIIHHd5hctDC1+giX38ZrzzCb1n5cIp8NOZHahyU6XzS+G1lqFTFgMXBd6EFN5lejwM96nva+ynGrwPF+ka/i+x/NAp2GSsdQ6Ii3b0cVTlpFTkxVbDnxDjWxJE7FRyUToCz7qcgBNLl7Rj7MckJsVCxLEwg1S7HTWOtuNy42nuqd1n49zb5QKRdwkvFOkPVPkvE5/+Bgz+/svSnBafIhN9r2zD9wU/oLqVsg/sHGzscxkitjJFZsPe3mOb8DRTTsUghO/he/AYs4ncsqyPDVAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"Caniuse - CSS 自定义变量\"\n        title=\"\"\n        src=\"/static/15230aaca66d6ba258b5cb0c19676bdc/f570d/caniuse-css-custome-properties.png\"\n        srcset=\"/static/15230aaca66d6ba258b5cb0c19676bdc/0783d/caniuse-css-custome-properties.png 240w,\n/static/15230aaca66d6ba258b5cb0c19676bdc/782f4/caniuse-css-custome-properties.png 480w,\n/static/15230aaca66d6ba258b5cb0c19676bdc/f570d/caniuse-css-custome-properties.png 960w,\n/static/15230aaca66d6ba258b5cb0c19676bdc/5d6f6/caniuse-css-custome-properties.png 1269w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n      />\n  </span>\n  </a></p>\n<p>再比如「规则嵌套」的语法，<a href=\"https://tabatkins.github.io/specs/css-nesting/\">CSS Nesting</a> 已经在路上了，通过 <a href=\"https://www.npmjs.com/package/postcss-nesting\">PostCSS 插件</a> 的帮助，我们已经可以提前用上这个功能。</p>\n<p>至于 Mixin 之类的功能，目前好像还没有对应的提案。</p>\n<p>我们期待 CSS 能够像 JS 一样蓬勃发展，毕竟在兼容性问题上，JS 可以通过添加 Polyfill 来优雅降级，但 CSS 就只能改用老旧的实现（比如用 float 来布局）。</p>\n<p>但是站在实用的角度，与其花时间折腾这些还不稳定的特性，不如老老实实用工具，毕竟技术是用来实现业务的，后者才是首要的问题。</p>\n<h1>来看看它的竞争对手</h1>\n<p>除了 SCSS，市面上可选的样式解决方案有很多，比较主流的有下面这几个：</p>\n<ul>\n<li>SASS</li>\n<li>LESS</li>\n<li>Stylus</li>\n<li>PostCSS</li>\n<li>原生 CSS</li>\n<li>CSS Modules</li>\n<li>styled-components</li>\n</ul>\n<h2>SASS</h2>\n<p>是的，你没看错，虽然师出同门，名字也只有一字之差，但 SASS 和 SCSS 终究是两个派系。</p>\n<p>讲究一点的话，这个预处理的官方名字叫 Sass（注意看大小写），SASS 和 SCSS 是 Sass 的两种语法。</p>\n<p>除了文件扩展名上的差异，SASS 和 SCSS 唯一的区别就是前者不加花括号和分号，依靠缩进来控制段落。如果你用过 Python，你一定觉得很眼熟。但更多的人（包括我）倾向于使用更接近标准的语法，因此官方最终把 SCSS 作为了推荐语法，SASS 作为保留语法。</p>\n<p>当然大部分人没这么「讲究」，通常所说的 SCSS 其实就是指采用了这种语法的 Sass。</p>\n<p>除此之外，SASS 和 SCSS 在功能上毫无差别。（很难相信官方居然因为这种事而硬生生划分出了两个派系）</p>\n<blockquote>\n<p>你知道吗？</p>\n<p>Sass 背后的开发语言已经从 <a href='https://sass-lang.com/ruby-sass' target='_blank'>Ruby</a> 迁移到了 <a href='https://github.com/sass/dart-sass#why-dart' target='_blank'>Dart</a>。当然，对于我们使用者来说，或许影响不大，我们依然只需要从 npm 安装 <code class=\"gatsby-code-text\">sass</code> 和 <code class=\"gatsby-code-text\">node-sass</code> 这两个依赖即可。</p>\n</blockquote>\n<h2>LESS</h2>\n<p>LESS 应该是和 SCSS 最接近的 CSS 预处理器了，两者在常用功能上并没有太大的差异，但是 SCSS 被公认拥有更强大的功能。</p>\n<p>LESS 是我在接触 SCSS 之前使用的最多的预处理器，之所以转投后者，主要有两方面原因。一方面是语法上的偏好，LESS 使用 <code class=\"gatsby-code-text\">@</code> 开头的字符串声明变量，这和 CSS 本身的一些语法有重叠，表意上容易让人混淆；LESS 使用 class 来定义 mixin，这种方式如果不加以规范，很容易让人混淆一个 class 到底是辅助工具还是样式本体。另一方面是因为 SCSS 的功能更加强大，在做长期的技术选型的时候，面对两个同样是开源项目、使用成本几乎相同、功能上一个大而全一个小而美的时候，我选择了大而全。</p>\n<p>但这并不代表 LESS 就是个辣鸡，对于不用追求大而全的项目，完全可以把 LESS 当做一个轻量级的 SCSS，处理日常业务完全没问题，小而美毕竟还是美的。Ant Design 就是用 LESS 开发的，有阿里爸爸的背书，应该不会心里没底了吧。</p>\n<p>哦对了，LESS 的另一个卖点是基于 Node 开发，如果你崇尚信仰，那么这也是一个理由。</p>\n<h2>Stylus</h2>\n<p>预处理圈有这么一股清流，叫做 Stylus。这是一把传说中的兵器，听过它的人不少，用它的人很少。</p>\n<p>Stylus 就像是一个轻量级的 SASS，支持不加花括号和分号，算是 Stylus 的一个主打卖点吧。但和 SASS 的强硬态度不同，在 Stylus 里这些都是可选的，你完全可以保留花括号和分号，可如果这样，和 SCSS、LESS 还有什么区别？我又为什么要选择 Stylus 呢？</p>\n<p>Stylus 定义变量和 Mixin 的方式也很奇特，不加任何前缀，直接写变量名，并且允许和 CSS 原生属性同名。这种操作，如果不加以规范，这很容易让人搞不清楚这到底是个变量还是个属性，而且在某些场合还会省略键值之间的冒号，这就更让人搞不清这一行改如何断句了。</p>\n<p>总之 Stylus 给我的最大感受是它想在极简主义的道路上做到极致，把一切能省掉的都省掉，想法不错，只可惜我不是个偏执狂，我不想为了几个字节的差别，总是在语法上费心。我唯一能想到的选择 Stylus 的理由，就是信仰 —— 没错，这货和 LESS 一样，也是基于 Node 开发的。</p>\n<p>写到这里，不由地进入了脑洞时间。LESS 和 Stylus 的设计目的，会不会就是想做轻量级的 Sass 替代品？</p>\n<p>没有戳到开发者的痛点，相比竞争对手又缺少差异性，这大概就是为什么 Stylus 会沦为「Yet Another CSS Pre-Processor」。</p>\n<h2>PostCSS</h2>\n<p>与前面几位选手不同的是，PostCSS 是一款基于 JS 的 CSS 插件系统，可以用 JS 来控制 CSS 的生成，例如：自动补全 <code class=\"gatsby-code-text\">-webkit-</code> 等前缀、添加对 <code class=\"gatsby-code-text\">flex</code> 旧版本语法的兼容、提供对一些 CSS 新特性的支持、压缩 CSS 代码等。</p>\n<p>PostCSS 既可以作为一个独立的 CSS 处理器来使用，也可以结合任何一款预处理器一起用。在插件系统的加持下，预处理器中你所熟悉的那些功能在 PostCSS 的生态中几乎都能找到对应的插件，只要你愿意折腾，没有什么不可以，你甚至可以用你熟悉的 JS 自己动手实现一些功能，而不用等官方来提供。</p>\n<p>显然我是个怕麻烦的人，不想自己去攒一套预处理系统，所以我还是用现成的好了。</p>\n<h2>原生 CSS</h2>\n<p>工具是很好用，但也别忘了我们的小祖宗，原生 CSS 发展到今天也是很能打的。</p>\n<p>新特性很好用</p>\n<p>兼容性不足，目前仅移动端可用。</p>\n<p>不支持嵌套语法</p>\n<h2>CSS Modules</h2>\n<p>React 的流行带火了 CSS-in-JS 的方案。CSS Modules 是其中最出名的一个。</p>\n<p>很好的解决了冲突的问题，但并不能很好的处理样式覆盖的需求。</p>\n<p>尤其当你用它开发了一套基础组件，而使用者想要对其进行样式覆盖的时候。</p>\n<p>其实我觉得冲突这种时候，通过命名规范来实现更好些，比如 BEM。</p>\n<h2>styled-components</h2>\n<p>同类的还有 <a href='https://emotion.sh' target='_blank'>Emotion</a>、<a href='https://www.styletron.org/' target='_blank'>Styletron</a> 等</p>\n<p>样式和逻辑混杂，导致代码行数增加，代码臃肿</p>\n<p>缺少可识别的标识符，难以调试，埋没在乱码中</p>\n<p>CSS Modules 至少还能通过前缀看出这是哪个 class</p>\n<p>如果不是 React Native，我想这项目应该火不了，即便如此，社区还是想方设法把 less、scss 这些给弄了进来。</p>\n<h1>说一嘴 CSS-in-JS</h1>\n<p>不少文章鼓吹 CSS-in-JS 对于 All-in-JS 的观点，我不是很赞同。JSX 我可以理解，但 CSS-in-JS 或许并不那么美好，至少在 Web 端是这样，</p>\n<p>CSS-in-JS 的存在主要还是为了 React Native 和 Flutter 等因为技术原因不方便直接使用 CSS 的方案。</p>\n<h1>State of CSS</h1>\n<p>这里有一份调查数据供大家参考：<a href='https://github.com/StateOfJS/StateOfJS/blob/master/surveys/stateofcss/2019/src/data/results/tools/pre-post-processors.yml' target='_blank'>State of CSS 2019</a>。</p>\n<p>这是著名调查系列 <a href='https://stateofjs.com/' target='_blank'>State of JavaScript</a> 的衍生产品。尽管官方还没把这个结果公示出来，但调查已经结束，结果不会再变了，只是差一个展示页罢了）</p>\n<h1>小结</h1>\n<p>这篇文章包含了大量的主观成分，但挑起派系之争从来不是我写作的目的，「前端娱乐圈」从来不乏这一类的文字。我所做的只不过是把我个人的选择过程分享给大家，给正在纠结要如何选择的朋友们一点点参考。</p>\n<p>存在即合理，任何有不止一个人喜欢的东西都一定是做对了什么。从实用的角度，本文提到的所有方案都可以满足业务开发的需要。本文讨论的不是能不能的问题，而是怎样更好的问题。</p>\n<p>你不需要同意我的每一个观点，也不用为你之所选正名，萝卜和青菜是分不出胜负的。</p>\n<p>当然，不同的声音永远是欢迎的，我也很好奇你的最爱是什么？你又是因为什么而选择了它？</p>","frontmatter":{"title":"我为什么选择 SCSS","description":"这就是，爱~~~","cover":{"publicURL":"/static/why-scss-aebc1be38700efdaeffae7d70937ab37.jpg"},"tags":["css","scss","sass"],"series":"","draft":true},"fields":{"id":"why-scss","date":"2019-05-04T16:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/05/05/why-scss"}}
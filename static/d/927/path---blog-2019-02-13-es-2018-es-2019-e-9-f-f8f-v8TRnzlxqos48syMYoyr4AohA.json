{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>ES2018</h2>\n<p>放心，SSR 没出事。</p>\n<p>写这篇博客并不是想说 SSR 有什么不好，而是因为一些别的原因。</p>\n<p>[译]我们为什么要写 super(props)?\n原文地址：Why Do We Write super(props) ?\n原文作者：Dan Abramov\n译者：Washington Hua\n我听说 Hooks 最近很火。讽刺的是，我想以一些关于 class 组件的有趣故事来开始这个博客。怎样！（皮一下很开心）</p>\n<p>这些小坑并不会影响你高效的使用 React，但如果你愿意深入了解下背后的工作原理，你会发现它们非常有意思。</p>\n<p>这是第一个。</p>\n<p>我这辈子写过的 super(props) 比我想象的要多得多</p>\n<p>class Checkbox extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { isOn: true };\n}\n// ...\n}复制代码\n当然，class fields proposal 允许我们跳过这个仪式。</p>\n<p>class Checkbox extends React.Component {\nstate = { isOn: true };\n// ...\n}复制代码\n这样的语法是在 2015 年 React 0.13 增加对纯 Class 的支持的时候加入 计划 的. 定义 constructor 和调用 super(props) 一直都只是 class fiels 出现之前的临时解决方案。</p>\n<p>然而，让我们只用 ES2015 的特性来回顾一下这个例子。</p>\n<p>class Checkbox extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { isOn: true };\n}\n// ...\n}复制代码\n我们为什么要调用super？能不能不调用它？如果非要调用，如果不传 props 会怎样？还有其它参数吗？让我们来看一下。</p>\n<p>在 JavaScript 中，super 指代父类的构造函数。（在我们的案例中，它指向 React.Component 这个实现）</p>\n<p>重点在于，在你调用父类构造函数之前，你无法在构造函数中使用 this。JavaScript 不会允许你这么做。</p>\n<p>class Checkbox extends React.Component {\nconstructor(props) {\n// 🔴 这时候还不能使用 <code class=\"gatsby-code-text\">this</code>\nsuper(props);\n// ✅ 现在开始可以了\nthis.state = { isOn: true };\n}\n// ...\n}复制代码\nJavaScript 强制你在使用 this 前运行父类构造函数有一个很好的理由。考虑这样一个类结构：</p>\n<p>class Person {\nconstructor(name) {\nthis.name = name;\n}\n}</p>\n<p>class PolitePerson extends Person {\nconstructor(name) {\nthis.greetColleagues(); // 🔴 这是不允许的，下面会解释原因\nsuper(name);\n}</p>\n<p>  greetColleagues() {\nalert('Good morning folks!');\n}\n}复制代码\n想象一下如果在调用 super 前使用 this 是被允许的。一个月之后。我们或许会改变 greetColleagues 把 person 的 name 加到消息中。</p>\n<p>greetColleagues() {\nalert('Good morning folks!');\nalert('My name is ' + this.name + ', nice to meet you!');\n}复制代码\n但我们忘了 this.greetColleagues() 是在 super() 有机会设置 this.name 之前被调用的。this.name 甚至还没被定义！如你所见，像这样的代码理解起来会很困难。</p>\n<p>为了避免这样的陷阱，JavaScript 强制规定，如果你想在构造函数中只用this，就必须先调用 super。让父类做它该做的事！这一限制也适用于定义成类的 React 组件。</p>\n<p>constructor(props) {\nsuper(props);\n// ✅ 现在可以使用 <code class=\"gatsby-code-text\">this</code> 了\nthis.state = { isOn: true };\n}复制代码\n这给我们留下了另一个问题：为什么要传 props？</p>\n<p>你或许觉得把 props 传进 super 是必要的，这使得基类 React.Component 可以初始化 this.props：</p>\n<p>// React 内部\nclass Component {\nconstructor(props) {\nthis.props = props;\n// ...\n}\n}复制代码\n很接近了——事实上，它就是这么做的。</p>\n<p>然而，即便在调用 super() 时没有传入 props 参数，你依然能够在 render 和其它方法中访问 this.props。（你要是不相信我，可以自己试一试）</p>\n<p>这是什么原理？其实 React 在调用你的构造函数之后，马上又给实例设置了一遍 props：</p>\n<p>// React 内部\nconst instance = new YourComponent(props);\ninstance.props = props;复制代码\n因此，即便你忘了把 props 传入 super()，React 依然会在事后设置它们。这是有理由的。</p>\n<p>当 React 添加对 Class 的支持时，它并不是只添加了对 ES6 的支持，而是希望能够支持尽可能广泛的 class 抽象。由于不是很确定 ClojureScript、CoffeeScript、ES6、Fable、Scala.js、TypeScript 或其他解决方案谁更适合用来定义组件，React 对于是否有必要调用 super() 刻意不表态。</p>\n<p>那么这是否意味着你可以只写 super() 而不用 super(props)？</p>\n<p>或许并非如此，因为这依然让人困扰。诚然，React 会在你的构造函数运行之后设置 this.props。但在 super 调用一直到构造函数结束之前，this.props 依然是未定义的。</p>\n<p>// React 内部\nclass Component {\nconstructor(props) {\nthis.props = props;\n// ...\n}\n}</p>\n<p>// 你的代码\nclass Button extends React.Component {\nconstructor(props) {\nsuper(); // 😬 我们忘了传入 props\nconsole.log(props);      // ✅ {}\nconsole.log(this.props); // 😬 undefined\n}\n// ...\n}复制代码\n如果这发生在某些从构造函数中调用的函数，调试起来会更加麻烦。这也是为什么我推荐总是使用 super(props) 的写法，即便这是非必要的：</p>\n<p>class Button extends React.Component {\nconstructor(props) {\nsuper(props); // ✅ 我们传了 props\nconsole.log(props);      // ✅ {}\nconsole.log(this.props); // ✅ {}\n}\n// ...\n}复制代码\n这样的写法确保了 this.props即便在构造函数返回之前就被设置好了。</p>\n<p>最后还有一点是 React 的长期用户或许会好奇的。</p>\n<p>你或许已经注意到，当你在 Class 中使用 Context API 时（无论是旧版的语法还是 React 16.6 中新增的现代化语法），context 是被作为构造函数的第二个参数传入的。</p>\n<p>那么我们为什么不写 super(props, context) 呢？当然我们可以这么做，但 context 的使用频率没那么高，所以这个陷阱影响还没那么大。</p>\n<p>伴随着 class fields proposal 的发布，这个问题也就不复存在了。即便不显式调用构造函数，所有参数也会自动传入。这就允许像 state = {} 这样的表达式在必要时可以直接引用 this.props. 或 this.context。</p>\n<p>在 Hooks 中，我们甚至都没有 super 或 this。这个话题我们择日再说。</p>","frontmatter":{"title":"你可能已经知道的 ES 2018 和 2019","description":"跟上时代的步伐","cover":{"publicURL":"/static/es2019-5646b4878e533cd7c725ce4c17984071.jpg"},"tags":["ecmascript","2018","2019"],"series":null,"draft":true},"fields":{"id":"es2018-es2019","date":"2019-02-12T16:00:00.000Z"}}},"pageContext":{"slug":"/blog/2019/02/13/es2018-es2019"}}
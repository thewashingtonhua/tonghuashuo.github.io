{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>标准这事儿吧……</h2>\n<p>ES 2019（ES 10）标准于年前正式发布，借此机会，我们来看看都有哪些特性有幸转正吧。顺带把 ES 2018 的内容也补一下。</p>\n<p>ECMAScript 标准的制定过程，自 2015 年大改，至今已经是第 5 个年头了，想必大家都心里有数了。与 Java 等语言不同，JS 并非先制定标准再开始使用，恰恰相反，是大家先用着，觉得合适的，才收录进标准。标准的存在更像是一个“年度优秀特性合集”。对绝大部分开发者来说，一项特性进没进标准不重要，Babel 支不支持才重要。标准你随便写，不用 Babel 算我输。</p>\n<p>那么接下来，我们就来看看 2018 和 2019 两个年度的大合集都有些啥吧。</p>\n<h2>ES2018（ES9）</h2>\n<h3>1）异步迭代器（Asynchronous Iteration）</h3>\n<p>总有那么些时候，我们会想要同步执行一些异步的操作，比如下面这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">const</span> actions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>利用 <code class=\"gatsby-code-text\">async / await</code> 语法，我们可以很轻松的做到这点。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">process</span> <span class=\"token punctuation\">(</span>actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> action <span class=\"token keyword\">of</span> actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面的写法，会按顺序执行 <code class=\"gatsby-code-text\">asyncFunc</code>，上一个结束之后才会开始下一个，每次得到的 <code class=\"gatsby-code-text\">action</code> 都是一个异步操作本身（比如这里是一个 Promise 对象）。</p>\n<p>ES 2018 为我们提供了一种新的方式，在前面代码的基础之上，让每次得到的 <code class=\"gatsby-code-text\">action</code> 直接是异步操作完成之后的结果（比如这里是 Promise 被 resolve 之后的结果）。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">process</span> <span class=\"token punctuation\">(</span>actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> action <span class=\"token keyword\">of</span> actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>2）“其余属性”和“扩展运算符” 开始适用于对象</h3>\n<p>这是一个从 ES 2015 开始就被广泛使用的特性，只不过 ES 2015 的标准只支持用于数组，从 ES 2018 开始也支持对象了。</p>\n<p>事实上 Map、Set、String 同样支持 <code class=\"gatsby-code-text\">...</code>，但具体是哪个版本引入的我还真没数。（反正我已经用了很久了，不管了）</p>\n<h3>3）Promise.finally</h3>\n<p>正如它的名字，finally。这也是个用了好久终于进标准的特性。</p>\n<p>在处理 Promise 的返回时，我们经常会遇到这样的情况：无论结果状态是 resolved 还是 rejected，都执行一样的逻辑。</p>\n<p>早先遇到这种情况，我们不得不在 <code class=\"gatsby-code-text\">then()</code> 和 <code class=\"gatsby-code-text\">catch()</code> 里都写一遍，现在可以一次性写在 <code class=\"gatsby-code-text\">finally()</code> 里。一个 <code class=\"gatsby-code-text\">finally()</code> 就等价于一组回调函数相同的 <code class=\"gatsby-code-text\">then()</code> 和 <code class=\"gatsby-code-text\">catch()</code>。</p>\n<p>虽然名字叫“最终”，但并不代表这是 Promise 执行的终点。<code class=\"gatsby-code-text\">finally()</code> 后面还可以继续跟 <code class=\"gatsby-code-text\">then()</code> 和 <code class=\"gatsby-code-text\">catch()</code>，无限跟。</p>\n<h3>4）移除对“在‘带标签的模版字面量’中使用非法转义序列”的限制</h3>\n<p>从这里开始的内容比较高阶，一般用不到，赶时间的话你可以跳过，直接去看 ES 2019。</p>\n<p>这一节的标题有点绕，我们拆开来讲。首先是“带标签的模版字面量”。</p>\n<p>ES 2015 引入了“模板字面量”的特性，相信大家都很熟悉了，长这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span>\n<span class=\"token keyword\">const</span> greetings <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`Hi, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span> <span class=\"token comment\">// 'Hi, John'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>这个特性有一个生僻用法，它允许我们自定义一个字符串模板函数，比如下面这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">myTag</span><span class=\"token punctuation\">(</span>strings<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// strings: ['that ', ' is a ', '']</span>\n\n  <span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> params<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> age <span class=\"token operator\">=</span> params<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> title <span class=\"token operator\">=</span> age <span class=\"token operator\">></span> <span class=\"token number\">99</span> <span class=\"token operator\">?</span> <span class=\"token string\">'centenarian'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'youngster'</span>\n\n  <span class=\"token keyword\">return</span> strings<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> name <span class=\"token operator\">+</span> strings<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> title\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token string\">'Mike'</span>\n<span class=\"token keyword\">const</span> age <span class=\"token operator\">=</span> <span class=\"token number\">28</span>\n<span class=\"token keyword\">const</span> output <span class=\"token operator\">=</span> myTag<span class=\"token template-string\"><span class=\"token string\">`that </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span> person <span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> is a </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span> age <span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span>\n<span class=\"token comment\">// that Mike is a youngster</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这就是“带标签的模版字面量”。尽管我严重怀疑这个用法的实用性（或许是觉得这样更加语义化？普通函数语义也不差啊？），但 ES 2018 还是选择了对这个特性进行完善。</p>\n<p>ES 2016 为这个特性加入了对转义序列的支持，比如八进制（\\ 开头）、十六进制（\\x 开头）、Unicode 字符（\\u 开头），但前提必须是一个有效的转义序列。如果是无效的序列，会报错。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\">latex<span class=\"token template-string\"><span class=\"token string\">`\\u00A9`</span></span>   <span class=\"token comment\">// 合法，表示“版权符号”</span>\nlatex<span class=\"token template-string\"><span class=\"token string\">`\\unicode`</span></span> <span class=\"token comment\">// 不合法，报错</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>ES 2018 去掉了这个限制，主要是考虑到对一些领域特定语言的支持，比如 <a target='_blank' href='https://www.latex-project.org/'>LaTeX</a>。（学术界一种常用的标记型语言，类似 HTML，其语法会用到大量形如转义序列的指令，如<code class=\"gatsby-code-text\">\\section</code>、<code class=\"gatsby-code-text\">\\frac</code>、<code class=\"gatsby-code-text\">\\sum</code> 等）</p>\n<p>但去掉限制只是说不报错了，模板中的无效转义序列会被替换为 undefined。比如下面这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">myTag</span> <span class=\"token punctuation\">(</span>template<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">,</span> params <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token string\">'foo'</span>\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span>\nmyTag<span class=\"token template-string\"><span class=\"token string\">`aaa</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>foo<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\\unicode</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>bar<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">bbb`</span></span>\n<span class=\"token comment\">/* {\n  template: ['aaa', undefined, 'bbb', raw: ['aaa', '\\unicode', 'bbb]],\n  params: ['foo', 'bar']\n} */</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面的代码里，<code class=\"gatsby-code-text\">template</code> 是模板部分被 <code class=\"gatsby-code-text\">${foo}</code> 等变量分割形成的数组；<code class=\"gatsby-code-text\">params</code> 就是 <code class=\"gatsby-code-text\">${foo}</code> 等变量组成的数组。可以看到，<code class=\"gatsby-code-text\">\\unicode</code> 由于是无效的转义序列，被替换为 <code class=\"gatsby-code-text\">undefined</code>，但在 <code class=\"gatsby-code-text\">template.raw</code> 里得以保留。</p>\n<p><code class=\"gatsby-code-text\">template.raw</code> 是“带标签的模版字面量”中 <code class=\"gatsby-code-text\">template</code> 参数特有的一个属性，保存了未被替换的原始字符串。</p>\n<p>这样一来，既避免了报错，又保留了开发者自行处理这些转义序列的能力。</p>\n<h3>5）关于正则表达式的一些改进</h3>\n<h4>5.1）<code class=\"gatsby-code-text\">.</code> 支持匹配换行符</h4>\n<p>在正则表达式中，点号 <code class=\"gatsby-code-text\">.</code> 表示匹配任一单个字符，但不包含换行符（如：<code class=\"gatsby-code-text\">\\n</code>、<code class=\"gatsby-code-text\">\\r</code>、<code class=\"gatsby-code-text\">\\f</code> 等）。</p>\n<p>现在可以了。</p>","frontmatter":{"title":"你可能已经知道的 ES 2018 和 2019","description":"跟上时代的步伐","cover":{"publicURL":"/static/es2019-5646b4878e533cd7c725ce4c17984071.jpg"},"tags":["ecmascript","2018","2019"],"series":null,"draft":true},"fields":{"id":"es2018-and-es2019","date":"2019-02-08T16:00:00.000Z"}}},"pageContext":{"slug":"/blog/2019/02/09/es2018-and-es2019"}}
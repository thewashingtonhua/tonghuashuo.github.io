{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>标准这事儿吧……</h2>\n<p>年前，ES 2019（ES 10）标准正式发布，借着这个机会，我们来看看新的一年都有哪些特性有幸转正吧。顺带着，把 ES 2018 的内容也补一下。</p>\n<p>ECMAScript 标准的制定过程，自 2015 年大改，至今已经是第 5 个年头了，想必大家都心里有数了。与 Java 等语言不同，JS 并非先制定标准再开始使用，恰恰相反，是大家先用着，觉得合适的，才收录进标准。标准的存在更像是一个“年度优秀特性合集”。对绝大部分开发者来说，一项特性进没进标准不重要，Babel 支不支持才重要。标准你随便写，不用 Babel 算我输。</p>\n<p>那么接下来，我们就来看看 2018 和 2019 两个年度的大合集都有些啥吧。</p>\n<h2>ES2018（ES9）</h2>\n<h3>2018.1）异步迭代器（Asynchronous Iteration）</h3>\n<p>总有那么些时候，我们会想要同步执行一些异步的操作，比如下面这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">const</span> actions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>利用 <code class=\"gatsby-code-text\">async / await</code> 语法，我们可以很轻松的做到这点。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">process</span> <span class=\"token punctuation\">(</span>actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> action <span class=\"token keyword\">of</span> actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>上面的写法，会按顺序执行 <code class=\"gatsby-code-text\">asyncFunc</code>，上一个结束之后才会开始下一个，每次得到的 <code class=\"gatsby-code-text\">action</code> 都是一个异步操作本身（比如这里是一个 Promise 对象）。</p>\n<p>ES 2018 为我们提供了一种新的方式，在前面代码的基础之上，让每次得到的 <code class=\"gatsby-code-text\">action</code> 直接是异步操作完成之后的结果（比如这里是 Promise 被 resolve 之后的结果）。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-javascript line-numbers\"><code class=\"gatsby-code-javascript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">process</span> <span class=\"token punctuation\">(</span>actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token keyword\">await</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> action <span class=\"token keyword\">of</span> actions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>2018.2）“其余属性”和“扩展运算符” 开始适用于对象</h3>\n<p>这是一个从 ES 2015 开始就被广泛使用的特性，只不过 ES 2015 的标准只支持用于数组，从 ES 2018 开始也支持对象了。事实上 Map、Set、String 同样支持<code class=\"gatsby-code-text\">...</code>，但具体是哪个版本引入的，一时半会儿我还真无从考证。（反正这个特性我已经用了很久了，不管了）</p>\n<h3>2018.3）Promise.finally</h3>\n<p>和它的名字一样，finally，这可以算</p>\n<p>在处理 Promise 的返回时，我们经常会遇到这样的情况：无论结果状态是 resolved 还是 rejected，都执行一样的逻辑。最初</p>","frontmatter":{"title":"你可能已经知道的 ES 2018 和 2019","description":"跟上时代的步伐","cover":{"publicURL":"/static/es2019-5646b4878e533cd7c725ce4c17984071.jpg"},"tags":["ecmascript","2018","2019"],"series":null,"draft":true},"fields":{"id":"es2018-and-es2019","date":"2019-02-07T16:00:00.000Z"}}},"pageContext":{"slug":"/blog/2019/02/08/es2018-and-es2019"}}
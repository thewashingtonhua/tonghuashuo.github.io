{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<blockquote>\n<p>原文地址：<a target='_blank' href=https://overreacted.io/why-do-we-write-super-props/>Why Do We Write super(props)?</a></p>\n<p>原文作者：<a target='_blank' href=https://twitter.com/dan_abramov>Dan Abramov</a></p>\n</blockquote>\n<p>我听说 <a target='_blank' href='https://reactjs.org/docs/hooks-intro.html'>Hooks</a> 最近很火。讽刺的是，我想以一些关于 class 组件的有趣故事来开始这个博客。怎样！（皮一下很开心）</p>\n<p>这些小坑并不会影响你高效的使用 React，但如果你愿意深入了解下背后的工作原理，你会发现它们非常有意思。</p>\n<p>这是第一个。</p>\n<hr>\n<p>我这辈子写过的 <code class=\"gatsby-code-text\">super(props)</code> 比我想象的要多得多</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当然，<a target='_blank' href='https://github.com/tc39/proposal-class-fields'>class fields proposal</a> 允许我们跳过这个仪式。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样的语法是在 2015 年 React 0.13 增加对纯 Class 的支持的时候加入 <a target='_blank' href='https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers'>计划</a> 的. 定义 <code class=\"gatsby-code-text\">constructor</code> 和调用 <code class=\"gatsby-code-text\">super(props)</code> 一直都只是 class fiels 出现之前的临时解决方案。</p>\n<p>然而，让我们只用 ES2015  的特性来回顾一下这个例子。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>我们为什么要调用<code class=\"gatsby-code-text\">super</code>？能不能不调用它？如果非要调用，如果不传 <code class=\"gatsby-code-text\">props</code> 会怎样？还有其它参数吗？</strong>让我们来看一下。</p>\n<p>在 JavaScript 中，<code class=\"gatsby-code-text\">super</code> 指代父类的构造函数。（在我们的案例中，它指向 <code class=\"gatsby-code-text\">React.Component</code> 这个实现）</p>\n<p>重点在于，在你调用父类构造函数之前，你无法在构造函数中使用 <code class=\"gatsby-code-text\">this</code>。JavaScript 不会允许你这么做。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 🔴 还不能使用 `this`</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ✅ 现在可以了</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>JavaScript 强制你在使用 <code class=\"gatsby-code-text\">this</code> 前运行父类构造函数有一个很好的理由。考虑这样一个类结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 This is disallowed, read below why</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>想象一下如果在调用 <code class=\"gatsby-code-text\">super</code> 前使用 <code class=\"gatsby-code-text\">this</code> 是被允许的。一个月之后。我们或许会改变 <code class=\"gatsby-code-text\">greetColleagues</code> 把 person 的 name 加到消息中。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'My name is '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', nice to meet you!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但我们忘了 <code class=\"gatsby-code-text\">this.greetColleagues()</code> 是在 <code class=\"gatsby-code-text\">super()</code> 有机会设置 <code class=\"gatsby-code-text\">this.name</code> 之前被调用的。<code class=\"gatsby-code-text\">this.name</code> 甚至还没被定义！如你所见，像这样的代码理解起来会很困难。</p>\n<p>为了避免这样的陷阱，<strong>JavaScript 强制规定，如果你想在构造函数中只用<code class=\"gatsby-code-text\">this</code>，就必须先调用 <code class=\"gatsby-code-text\">super</code></strong>。让父类做它该做的事！这一限制也适用于定义成类的 React 组件。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ✅ 现在可以使用 `this` 了</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这给我们留下了另一个问题：为什么要传 <code class=\"gatsby-code-text\">props</code>？</p>\n<hr>\n<p>你或许觉得把 <code class=\"gatsby-code-text\">props</code> 传进 <code class=\"gatsby-code-text\">super</code> 是必要的，这使得基类 <code class=\"gatsby-code-text\">React.Component</code> 可以初始化 <code class=\"gatsby-code-text\">this.props</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// 在 React 内部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>很接近了——事实上，<a target='_blank' href='https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22'>它就是这么做的</a>。</p>\n<p>然而，即便在调用 <code class=\"gatsby-code-text\">super()</code> 时没有传入 <code class=\"gatsby-code-text\">props</code> 参数，你依然能够在 <code class=\"gatsby-code-text\">render</code> 和其它方法中访问 <code class=\"gatsby-code-text\">this.props</code>。（你要是不相信我，可以自己试一试）</p>\n<p>这是什么原理？其实 <strong>React 在调用你的构造函数之后，马上又给实例设置了一遍 <code class=\"gatsby-code-text\">props</code></strong>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// 在 React 内部</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>因此，即便你忘了把 <code class=\"gatsby-code-text\">props</code> 传入 <code class=\"gatsby-code-text\">super()</code>，React 依然会在事后设置它们。这是有理由的。</p>\n<p>当 React 添加对 Class 的支持时，它并不是只添加了对 ES6 的支持，而是希望能够支持尽可能广泛的 class 抽象。由于 <a target='_blank' href='https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages'>不是很确定</a> ClojureScript、CoffeeScript、ES6、Fable、Scala.js、TypeScript 或其他解决方案谁更适合用来定义组件，React 对于是否有必要调用 <code class=\"gatsby-code-text\">super()</code> 刻意不表态。</p>\n<p>那么这是否意味着你可以只写 <code class=\"gatsby-code-text\">super()</code> 而不用 <code class=\"gatsby-code-text\">super(props)</code>？</p>\n<p><strong>或许并非如此，因为这依然让人困扰</strong>。诚然，React 会在你的构造函数运行之后设置 <code class=\"gatsby-code-text\">this.props</code>。但在 <code class=\"gatsby-code-text\">super</code> 调用一直到构造函数结束之前，<code class=\"gatsby-code-text\">this.props</code> 依然是未定义的。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// 在 React 内部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Inside your code</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😬 我们忘了传入 props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ✅ {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😬 undefined</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果这发生在某些从构造函数中调用的函数，调试起来会更加麻烦。<strong>这也是为什么我推荐总是使用 <code class=\"gatsby-code-text\">super(props)</code> 的写法，即便这是非必要的</strong>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-jsx line-numbers\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 我们传入了 props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ✅ {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样的写法确保了 <code class=\"gatsby-code-text\">this.props</code>即便在构造函数返回之前就被设置好了。</p>\n<hr>\n<p>最后还有一点是 React 的长期用户或许会好奇的。</p>\n<p>你或许已经注意到，当你在 Class 中使用 Context API 时（无论是旧版的语法还是 React 16.6 中新增的现代化语法），context 是被作为构造函数的第二个参数传入的。</p>\n<p>那么我们为什么不写 <code class=\"gatsby-code-text\">super(props, context)</code> 呢？当然我们可以这么做，但 context 的使用频率没那么高，所以这个陷阱影响还没那么大。</p>\n<p><strong>伴随着 class fields proposal 的发布，这个问题也就不复存在了。</strong>即便不显式调用构造函数，所有参数也会自动传入。这就允许像 <code class=\"gatsby-code-text\">state = {}</code> 这样的表达式在必要时可以直接引用 <code class=\"gatsby-code-text\">this.props.</code> 或 <code class=\"gatsby-code-text\">this.context</code>。</p>\n<p>在 Hooks 中，我们甚至都没有 <code class=\"gatsby-code-text\">super</code> 或 <code class=\"gatsby-code-text\">this</code>。这个话题我们择日再说。</p>","frontmatter":{"title":"【译】我们为什么要写 super(props)?","description":"好像知道，又好像不知道","cover":{"publicURL":"/static/overreacted-9fbf74366dc5b9e4aab57572a9f0470d.jpg"},"tags":["react"],"series":"overreacted","draft":false},"fields":{"id":"why-do-we-write-super-props","date":"2019-02-21T16:00:00.000Z"}}},"pageContext":{"slug":"/blog/2019/02/22/why-do-we-write-super-props"}}
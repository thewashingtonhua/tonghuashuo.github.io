{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>写在前面</h2>\n<p>React 组件的生命周期，相信大家都非常熟悉了，无非那么几个函数，官方文档已经写得非常清楚了。</p>\n<p>（那还有什么好说的？浪费生命！合上！）</p>\n<p>一般我们所讨论的，都是单个组件的生命周期。如果是多个组件之间呢？比如父子组件？兄弟组件？各个周期又是什么样的？异步路由的情况呢？前阵子新出的 Hooks 呢？有几个人敢站出来说我全知道的？（反正我是不敢）</p>\n<p>刚好也是最近遇到一些关于生命周期的问题，项目中涉及到大量的异步操作，需要清楚地知道各部分的执行顺序，借此机会整理一下。</p>\n<h2>在你继续之前</h2>\n<p>这篇文章并不是入门教学，如果你对 React 一点不了解的话，你会发现这篇文章难以理解。</p>\n<p>我假定你已经掌握 React 的基本知识，例如：组件的生命周期、Hooks 的基本用法、类组件和函数组件的区别 等，并用 React 开发过一些多页面的应用。</p>\n<p>这里我们不考虑 <code class=\"gatsby-code-text\">shouldComponentUpdate</code>、<code class=\"gatsby-code-text\">React.memo</code> 等优化手段，只考虑最原始的情况。</p>\n<p>本文以浏览器作为目标环境，React Native 和 Electron 在基本概念上是一样的，细节上的不同不作为本文的讨论重点，</p>\n<h2>那么我们就来做个实验吧</h2>\n<p>为了一探究竟，我写了一个 <a href=\"https://tonghuashuo.github.io/react-lifecycle\">Demo</a> 来模拟一些常见的用例：父子组件、兄弟组件、同步/异步路由、类组件和使用了 Hooks 的函数组件、页面初始化时的异步操作（如访问 API）等。主要观察下面这些情况：</p>\n<ul>\n<li>父子组件之间。</li>\n<li>兄弟组件之间。</li>\n<li>同步路由和异步路由。</li>\n<li>类组件和使用了 Hooks 的函数组件。</li>\n</ul>\n<p>如果你有遇到 Demo 没覆盖到的使用场景，欢迎提 Issue。</p>\n<h2>TL,DR;</h2>\n<p>我知道大家的时间都很宝贵，赶时间的朋友可以直接看结论；时间宽裕的朋友，我们从下一节开始细聊：</p>\n<ol>\n<li>同步路由，父组件在 <code class=\"gatsby-code-text\">render</code> 阶段创建子组件。</li>\n<li>异步路由，父组件在自身挂载完成之后才开始创建子组件。</li>\n<li>无论是挂载还是更新，以 <code class=\"gatsby-code-text\">render</code> 完成为界，之前父组件先执行，之后子组件先执行。</li>\n<li>兄弟组件大体上按照在父组件中的出场顺序执行。</li>\n<li><code class=\"gatsby-code-text\">useEffect</code> 会延迟执行。</li>\n<li>异步请求（如访问 API）何时得到响应与组件的生命周期无关，即父组件中发起的异步请求不保证在子组件挂载完成前得到响应。</li>\n</ol>\n<h2>加载过程</h2>\n<p>组件树的加载分为三个阶段。</p>\n<p>第一阶段，父组件执行到自身的 <code class=\"gatsby-code-text\">render</code>，解析其下有哪些子组件需要渲染，并对其中同步的子组件进行创建，挨个执行各组件到 <code class=\"gatsby-code-text\">render</code>，生成到目前为止的 Virtual DOM 树，并 commit 到 DOM。</p>\n<p>第二阶段，此时 DOM 节点已经生成完毕，组件挂在完成，开始后续流程。同步子组件依次触发自己的 <code class=\"gatsby-code-text\">componentDidMount</code> / <code class=\"gatsby-code-text\">useLayoutEffect</code>；全部触发后，最后触发父组件的这些函数。</p>\n<p>第三阶段，如果组件是函数组件，并使用了 <code class=\"gatsby-code-text\">useEffect</code>，则会在第三阶段之后触发 <code class=\"gatsby-code-text\">useEffect</code>。</p>\n<p>如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p>\n<p>对于兄弟组件，如果是同步路由，它们的创建顺序和在父组件中定义的顺序是一致的。</p>\n<blockquote>\n<p>有一个细节我目前还不确定：当在父组件中同时加载多个异步子组件时，它们的最终加载顺序是按照 JSX 中定义的顺序，还是按照 js 文件下载完成的顺序。</p>\n<p>按照我对“异步”的理解，我更倾向于认为是按照下载完成的顺序，这更符合“按需加载”的特点。</p>\n<p>之所以会造成困扰，是因为据我目前所观察到的情况，两种顺序是一致的，我还没有遇到过后定义但先加载的情况。</p>\n<p>大部分时候我们会以页面为单位去划分异步组件，单个页面需要加载多个异步组件的场景比较少；即便在这些少数场景中，单次需要请求的文件数量也不会很多，不至于超过浏览器的并发上限；即便超过，也会按照在父组件中定义的先后顺序去分批发起请求，下载完成的顺序和定义的顺序基本上是一致的。再者单个异步组件的文件尺寸通常都很小，加载速度非常快，同时发起的请求基本上是同时到达的，在常规业务场景下，我们很难感受到差别。</p>\n<p>但没遇到不代表不存在，该问题我会进一步验证，已经有结果的小伙伴也可以分享一下。</p>\n</blockquote>\n<p>如果组件的初始化过程包含异步操作（通常在 <code class=\"gatsby-code-text\">componentDidMount()</code> 和 <code class=\"gatsby-code-text\">useEffect(fn, [])</code> 中进行），这些操作何时响应与组件的生命周期无关，完全看异步操作本身花了多少时间。（但通常发生在组件树全部挂载完成之后）</p>\n<h2>更新过程</h2>\n<p>React 的设计遵循单向数据流模型，任何组件更新导致其它组件更新的，本质上都可以归结为父组件更新导致子组件更新的情况。</p>\n<p>父子组件的更新同样以各组件的 <code class=\"gatsby-code-text\">render</code> 执行结束为界，分为两个阶段，每个阶段的生命周期执行顺序有所不同。</p>\n<p>第一个阶段到各组件的 <code class=\"gatsby-code-text\">render</code> 为止，在这个阶段父组件先于子组件执行。父组件在执行到 <code class=\"gatsby-code-text\">render</code> 时会重新分析哪些子组件需要重新渲染，然后挨个重新渲染。被重新渲染的子组件会依次执行自己的代码到 <code class=\"gatsby-code-text\">render</code> 为止。当父子组件都执行完 <code class=\"gatsby-code-text\">render</code> 之后，新的 Virtual DOM 树构建完成，进入下个阶段。</p>\n<p>第二个阶段，就是根据上阶段生成的 Virtual DOM 树，进行实际的渲染。这个阶段包含四个步骤：</p>\n<ol>\n<li><code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code></li>\n<li><code class=\"gatsby-code-text\">useLayoutEffect (Cleanup)</code></li>\n<li><code class=\"gatsby-code-text\">useLayoutEffect</code> / <code class=\"gatsby-code-text\">componentDidUpdate</code></li>\n<li><code class=\"gatsby-code-text\">useEffect</code></li>\n</ol>\n<p>React 会按照子组件先于父组件的顺序，依次执行每个步骤，例如先执行子组件的 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code>，然后是父组件的 <code class=\"gatsby-code-text\">getSnapshotBeforeUpdate</code>，再然后是子组件的 <code class=\"gatsby-code-text\">componentDidUpdate</code>，父组件的 <code class=\"gatsby-code-text\">componentDidUpdate</code>，以此类推。</p>\n<p>这里我们把类组件和函数组件的生命周期放在了一起，因为父子组件可以是这两种组件类型的任意排列组合，渲染时会按照组件的类型执行其所拥有的函数。</p>\n<h2>卸载过程</h2>\n<p>卸载过程涉及到 <code class=\"gatsby-code-text\">componentWillUnmount</code>、<code class=\"gatsby-code-text\">useEffect</code>、<code class=\"gatsby-code-text\">useLayoutEffect</code> 这三种函数，固定为父组件的先执行，子组件按照 JSX 中定义的顺序依次执行。对于使用了 Hooks 的组件，各 Effect 按照代码中定义的先后顺序执行各自的 Cleanup 函数（如果有的话）。</p>\n<p>注意当涉及页面切换时，新组件会先被创建并执行完 <code class=\"gatsby-code-text\">render</code>，然后卸载不需要的老组件，最后新组件完成最后的挂载。</p>\n<h2>Hooks</h2>\n<p>确切地说，Hooks 并不是一种新的组件写法，它只是一种代码复用的方式。所以当我们讨论 Hooks 的时候，我们其实是在讨论「函数组件」。</p>\n<p>在 Hooks 之前，函数组件是没有 state 的概念的，因此也就不存在生命周期一说，调用的时候只管执行就完了。但 Hooks 的出现，让函数组件也拥有了 state，进而也就引入了生命周期的概念。</p>\n<p>但函数组件的本质还是函数，「函数」是没有生命周期的，Hooks 的出现也并没有改变这一原理；这里我讨论的对象是「组件」，组件是可以有生命周期的。</p>\n<p>函数组件的生命周期和 Class 不太一样，它没有生命周期钩子函数，只管执行函数。具体到 Hooks 相关的部分，主要就是 <code class=\"gatsby-code-text\">useEffect()</code>、<code class=\"gatsby-code-text\">useLayoutEffect()</code> 具体何时执行的问题。</p>\n<p>根据 React 的官方文档，Hooks 中的 <code class=\"gatsby-code-text\">useEffect</code> 和 <code class=\"gatsby-code-text\">useLayoutEffect</code> 都是等效于 <code class=\"gatsby-code-text\">componentDidUpdate</code> / <code class=\"gatsby-code-text\">componentDidMount</code> 的存在，但这里有一个细节非常值得注意：<code class=\"gatsby-code-text\">useLayoutEffect</code> 永远比 <code class=\"gatsby-code-text\">useEffect</code> 先执行，即便在你的代码中 <code class=\"gatsby-code-text\">useEffect</code> 出现在 <code class=\"gatsby-code-text\">useLayoutEffect</code> 之前。<code class=\"gatsby-code-text\">useLayoutEffect</code> 才是事实上和 <code class=\"gatsby-code-text\">componentDidUpdate</code> / <code class=\"gatsby-code-text\">componentDidMount</code> 平起平坐的存在，<code class=\"gatsby-code-text\">useEffect</code> 会在 <code class=\"gatsby-code-text\">componentDidUpdate</code> / <code class=\"gatsby-code-text\">componentDidMount</code> 之后被触发，无论在子组件还是父组件中。当父子组件中都用到 <code class=\"gatsby-code-text\">useEffect</code> 时，子组件中的会比父组件中的先触发。</p>","frontmatter":{"title":"细究 React 生命周期","description":"事情好像没那么简单","cover":{"publicURL":"/static/react-lifecycle-0edf69056144aaf512a28d0670b53b57.jpg"},"tags":["react","lifecycle"],"series":"","draft":true},"fields":{"id":"react-lifecycle","date":"2019-03-24T16:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/03/25/react-lifecycle"}}
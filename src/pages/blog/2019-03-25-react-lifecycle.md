---
title: '说起 React 的生命周期，你或许还不知道……'
description: '事情好像没那么简单'
tags: ['react', 'lifecycle']
cover: '../../images/blog/react-lifecycle.jpg'
series: ''
draft: true
original: true
---

## 写在前面

React 组件的生命周期，相信大家都非常熟悉了，无非那么几个函数，官方文档已经写得非常清楚了。

（那还有什么好说的？浪费生命！合上！）

一般我们所讨论的，都是单个组件的生命周期。如果是多个组件之间呢？比如父子组件？兄弟组件？各个周期又是什么样的？异步路由的情况呢？前阵子新出的 Hooks 呢？有几个人敢站出来说我全知道的？（反正我是不敢）

刚好也是最近遇到一些关于生命周期的问题，项目中涉及到大量的异步操作，需要清楚地知道各部分的执行顺序，借此机会整理一下。

## 在你继续之前

这篇文章并不是入门教学，如果你对 React 一点不了解的话，你会发现这篇文章难以理解。

我假定你已经掌握 React 的基本知识，例如：组件的生命周期、Hooks 的基本用法、类组件和函数组件的区别 等，并用 React 开发过一些多页面的应用。

这里我们不考虑 `shouldComponentUpdate`、`React.memo` 等优化手段，只考虑最原始的情况。

## 那么我们就来做个实验吧

为了一探究竟，我写了一个 [Demo](https://tonghuashuo.github.io/react-lifecycle) 来模拟一些常见的用例：父子组件、兄弟组件、同步/异步路由、类组件和使用了 Hooks 的函数组件、页面初始化时的异步操作（如访问 API）等。主要观察下面这些情况：

- 父子组件之间各阶段的执行顺序。
- 兄弟组件之间各阶段的执行顺序。
- 异步路由时的加载顺序。
- Hooks 的生命周期。

如果你有遇到 Demo 没覆盖到的使用场景，欢迎提 Issue。

## TL,DR;

我知道大家的时间都很宝贵，赶时间的朋友可以直接看结论；时间宽裕的朋友，我们从下一节开始细聊：

1. 同步路由，父组件在 `render` 阶段创建子组件。
2. 异步路由，父组件在自身挂载完成之后，才会开始创建子组件。
3. 无论是挂载还是更新，到 `render` 为止，父组件先于子组件执行，之后的阶段子组件先于父组件执行。
3. 兄弟组件大体上按照在父组件中的出场顺序执行。
4. `useEffect` 是异步的，需要同步请使用 `useLayoutEffect`。
5. 异步请求（如访问 API）的响应时刻与其生命周期无关；父组件发起的请求不保证在子组件挂载完成前返回。

## 加载过程

父组件会在自身的 `render` 阶段，解析其下有哪些子组件，并在执行过程中对其中同步的子组件进行创建。

等所有同步子组件都挂载完成后，父组件才算挂载完成。

父组件中的异步子组件，则会在父组件挂载完成后被创建。

兄弟组件的创建顺序和它们在父组件中的出场顺序是一致的，当然会按照同步/异步分批进行。

> // TODO
>
> 有一个细节我目前还不确定：当在父组件中同时加载多个异步子组件时，它们的最终加载顺序是按照 JSX 中定义的顺序，还是按照 js 文件下载完成的顺序。
>
> 按照我对“异步”的理解，我更倾向于认为是按照下载完成的顺序。
>
> 之所以会造成困扰，是因为目前所观察到的情况是，两种顺序是一致的，我还没有遇到过后定义但先加载的情况。
>
> 大部分时候我们会以页面为单位去划分异步组件，单个页面需要加载多个异步组件的场景比较少；即便在这些少数场景中，单个异步组件的文件尺寸也都很小，需要加载的文件数量也不会很多，不至于超过浏览器的并发上限，因此下载完成的顺序和定义的顺序基本上是一致的。这就导致在常规业务场景下，我们很少能观察到这样的情况。
>
> 但没遇到不代表不存在，该问题我会进一步验证，已经有结果的小伙伴也可以分享一下。

如果组件的初始化过程包含异步操作（通常在 `componentDidMount()` 和 `useEffect(fn, [])` 中进行），这些操作何时响应与组件的生命周期无关，完全看异步操作本身花了多少时间。（但通常发生在组件树全部挂载完成之后）

## 更新过程

父组件更新导致子组件更新时：

子组件 `getSnapshotBeforeUpdate` 之后，并不是直接进入到自身的 `didUpdate`，而是先触发父组件的 `getSnapshotBeforeUpdate`。
上述过程之后，子组件先 `didUpdate`，然后才是父组件 `didUpdate`。


## Hooks

确切地说，Hooks 并不是一种新的组件写法，它只是一种代码复用的方式。所以当我们讨论 Hooks 的时候，我们其实是在讨论「函数组件」。

在 Hooks 之前，函数组件是没有 state 的概念的，因此也就不存在生命周期一说，调用的时候只管执行就完了。但 Hooks 的出现，让函数组件也拥有了 state，进而也就引入了生命周期的概念。

但函数组件的本质还是函数，「函数」是没有生命周期的，Hooks 的出现也并没有改变这一原理；这里我讨论的对象是「组件」，组件是可以有生命周期的。

函数组件的生命周期和 Class 不太一样，它没有生命周期钩子函数，只管执行函数。具体到 Hooks 相关的部分，主要就是 `useEffect()`、`useLayoutEffect()` 具体何时执行的问题。



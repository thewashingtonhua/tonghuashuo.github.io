<h2>模块化</h2>
<p>但凡有一定资历的开发者，对“模块化”的概念应该都非常熟悉了。C、PHP 有<span class='code'>include</span>、Java、Python 有<span class='code'>import</span>，Ruby 有<span class='code'>require</span>，连 CSS 都有<span class='code'>@import</span>。然而 JavaScript 却一直都没有语言层面的模块化方案 —— 直到 ES6。</p>

<h2>简史</h2>
<p>不过这个问题也不怪 JavaScript 的发明者，毕竟时代不同，当初的需求很简单，就只是一个简单的脚本语言。</p>
<p>随着 Web 的发展，JavaScript 被开发出更多的可能性，前端项目的复杂度与日俱增，语言特性的缺失成为了发展的瓶颈，于是便有了 ES6 大刀阔斧的变革。</p>
<p>在 ES6 之前，社区也曾出现过 CommonJS、AMD、CMD、UMD 等各种模块化方案。ES6 为我们带来了语言层面上的解决方案，我们称之为 ESM（ECMAScript Module），并且很快取代之前的所有方案，一统了江湖。</p>
<blockquote>由于一些历史原因，CommonJS 在未来很长一段时间还会继续存在，但 Node.js 的开发团队计划未来迁移到 ESM，为此正在研发一套平滑的迁移方案。对于普通开发者，只需要知道：万物终将基于 ESM。</blockquote>

<h2>静态加载</h2>
<p>熟悉 Node 的朋友应该都清楚，CommonJS 的模块本质就是一个对象，当我们<span class='code'>reuqire</span>一个模块的时候，会引入整个模块，也就是把整个对象给搬了过来，然后访问对象上的属性。这种模块加载方式我们称之为“动态加载”，因为只有在运行时才能得到这个对象。动态加载的好处是灵活方便，可以根据条件判断选择性地加载模块；坏处是要么不加载，要加载就是整个模块，没办法只加载用到部分（因此没法做 Tree-Shaking），而且没法在编译阶段做“静态优化”（实现 Tree-Shaking 的另一个阻碍）。</p>
<p>ESM 采用静态加载的方式，牺牲一部分灵活性（Dynamic Import 提案弥补了这一缺陷，现已进入 Stage-3，主流环境都已经支持，可以期待在 ES2019 中见到它），换取“静态优化”的可能性，大家熟悉的 Tree-Shaking、类型检测等功能都要归功于此。</p>

<h2>严格模式</h2>
<p>ESM 自动采用严格模式，无论是否在模块顶部加上<span class='code'>"use strict";</span></p>
<p>严格模式本身属于 ES5 的内容，ES6 并没有对其做修改，只是强制启用。换个角度理解，未来其实也就没有严格模式一说了，所有 JavaScript 代码都必须遵守严格模式的规则。</p>

<h2>export</h2>
<p>ESM 的核心是两个命令，<span class='code'>export</span>用于导出，<span class='code'>import</span>用于导入，非常直观。（从英文的角度，include 表示“包含”，被包含的代码块会被简单复制到引用之处；require 表示“需要”，import 表示“引进”，后两者虽然从英文语法上没有强调是“整体”还是“局部”，但和“包含”还有明显区别的）</p>
<p>ESM 中，一个模块就是一个独立的文件，文件中定义的变量，除非用<span class='code'>export</span>命令导出，在外部是无法访问的。</p>
<img src='/img/illustration/es6-daily/module-export.svg' alt=''>
<p><span class='code'>export</span>规定的是对外的接口，且必须和文件内的变量一一对应，不能直接导出一个直接量</p>
<img src='/img/illustration/es6-daily/module-export-interface.svg' alt=''>

<h2>未完待续</h2>

<!-- <h2>小结</h2>
<p></p> -->

<h2>该系列的其他文章</h2>
<p>上一篇：<a href="es6-daily-18-class.html">每天一点ES6(18)：Class</a></p>
<p>下一篇：<a href="javascript:;">每天一点ES6(20)：装饰器</a></p>
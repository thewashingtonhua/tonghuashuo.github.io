<h2>过去</h2>
<p>从我们学习 JavaScript 的第一天起，我们就被告知，JavaScript 是面向对象的，虽然它的语法和传统的 C 风格相去甚远，甚至有人并不认可 JavaScript 是面向对象的。但不管怎么说，这并不影响我们使用 JavaScript 去实现面向对象。</p>
<p>在过去（也就是 ES6 之前的时代），我们使用这样的语法来定义一个类：</p>
<img src='/img/illustration/es6-daily/class-es5.svg' alt=''>
<p>如今，你依然可以通过这种方式去定义一个类，当然我推荐你一个更好的方式：</p>

<h2>现在</h2>
<p>ES6 对开发者影响最大的改变之一，就是改变了类定义的语法（或者说“新增”比较合适，毕竟老的依然能用，只是不再推荐），使得在 JavaScript 中定义类的语法更加接近 C 风格，现在你可以使用如下的代码来重写上面的代码：</p>
<img src='/img/illustration/es6-daily/class-es6.svg' alt=''>
<p>运行一下，结果没有什么不同，但是语法看上去更符合我们的认知（请原谅一个毕业自常规本科教育的开发者的世界观）</p>

<h2>语法糖</h2>
<p>类定义语法的变更带给我的第一个疑虑是：我们接触了这么久的原型链机制，是否在 ES6 的新语法下也被改变了呢？并没有！</p>
<p>新语法的加入并没有改变 JavaScript 基于原型链的本质，只是在语法上更加符合了 C 风格。上面代码中的<span class='code'>constructor</span>和<span class='code'>toString</span>其实就是<span class='code'>Point.prototype.constructor</span>和<span class='code'>Point.prototype.toString</span>，Point 本身的类型也还是函数（就是<span class='code'>constructor</span>），一切只是换了个马甲而已，并没有本质上的区别。</p>
<p>如果我们把两种语法的代码整理成下面的样子，一切就很好理解了：</p>
<img src='/img/illustration/es6-daily/class-es6-2.svg' alt=''>

<h2>还是有变化的</h2>
<p>新的语法在使用上同样也受到其它 ES6 特性的影响，例如：新语法定义的类方法是不可枚举的，<span class='code'>Object.keys</span>不会得到任何内容，但<span class='code'>Object.getOwnPropertyNames</span>可以。类的属性名也可以采用表达式，<span class='code'>[variable]</span>是一个合法的属性名，具体取决于<span class='code'>variable</span>变量的取值，当然这不仅仅局限于类，这是 ES6 中对象的新特性。</p>

<h2>严格模式</h2>
<p>类内部是采用严格模式的，事实上 ES6 的另一个新特性“模块”（我们会在下一篇讲到）也是基于严格模式的，考虑到从 ES6 开始的代码都是运行在模块之中，可以说 ES6 在语言层面上就是按照严格模式来设计的，我们在使用时候就直接默认遵循严格模式来就好了，不用再做区分了。</p>

<h2>构造函数</h2>
<p>类的构造函数可以为空，甚至省略（JS 引擎会自动创建一个空的构造函数，因此实际上等效于为空），默认返回实例对象，但允许指定返回另一个对象。</p>
<p>类必须使用<span class='code'>new</span>进行调用，不能像普通函数一样直接调用，否则会报错。</p>

<h2>Class 表达式</h2>
<p>和函数表达式类似，类也支持这样的写法：</p>
<img src='/img/illustration/es6-daily/class-expression.svg' alt=''>
<p>需要注意的是，和函数表达式一样，<span class='code'>MyClass</span>才是真正的类名，<span class='code'>Me</span>只在类内部可以作为一个内部代号，指代自身，在类外部是访问不到的。</p>

<h2>立即执行的 Class</h2>
<p>听说过立即执行函数吧，这个也差不多，同样是临时定义立即调用：</p>
<img src='/img/illustration/es6-daily/class-expression-iife.svg' alt=''>

<h2>变量不提升</h2>
<p>类定义不存在变量提升，这一点有些特殊，但为了实现继承，这是必须的。</p>
<p>从最佳实践的角度，为了不给开发过程埋坑，最好还是手动提升变量，即始终遵循“先定义后使用”的规则，绕开可能的变化。即便发生提升也会得到相同的结果。</p>

<h2>私有属性和私有方法</h2>
<p>在传统的 C 风格中，属性前面都会有<span class='code'>public</span>、<span class='code'>protected</span>、<span class='code'>private</span>三大修饰符加持。虽然类语法的存在是为了让类定义的代码看起来更接近 C 风格，但 ES6 并没有加入这些修饰符，事实上，ES6 中类的属性和方法都还是公开的，虽然我们可以通过变量名前加下划线、立即执行函数、把私有变量移出模块等“自己骗自己”的方法来模拟，但这些都不是真正的私有。</p>
<p>关于这个问题，有一个颇具争议但看样子依然会被写进标准的提案，建议在属性名前加<span class='code'>#</span>来表示私有变量，并且在语言层面上支持私有变量。根据提案，<span class='code'>#</span>并不算是修饰符，而是变量名的一部分，也就是说<span class='code'>#x</span>和<span class='code'>x</span>是两个变量，虽然语法上允许这种形式的“重名”，但实际使用中建议还是避免这种骚操作。</p>
<p>至于为什么会选择<span class='code'>#</span>这个符号，据说主要有两个原因，一个是为了保留 JavaScript 是动态语言（没有类型申明）的特点，<span class='code'>private</span>不太适合，因此只能选择一个新的符号。Ruby 使用了<span class='code'>@</span>，但 ES6 在此之前已经把<span class='code'>@</span>用于了装饰器（后面文章会讲到），因此一通 pass 下来，好像就<span class='code'>#</span>还不错，就它了。</p>
<p>比较奇怪的是，尽管私有属性在实例上不可访问，但可以在类内部定义一个常规方法，接收一个实例作为参数，在方法中直接访问该实例的私有属性。这算是一个骚操作吧，不是很能理解为什么要这么设计，如果这个操作是通过调用 getter 函数来间接访问私有变量，似乎就合理多了。</p>

<h2>this</h2>
<p>类内部的<span class='code'>this</span>一律指向类的实例，只要你不做什么骚操作，你几乎不用担心<span class='code'>this</span>会指错。如果你非要展现自己风骚的一面，那就自求多福吧。（方法自然是有的，但你还是不知道的好，免得知道以后乱用）</p>

<h2>name</h2>
<p>由于类的本质依然是函数，因此函数的<span class='code'>name</span>属性在类中依然适用，可以返回类名。</p>

<h2>Generator</h2>
<p>如果某个方法之前加上了<span class='code'>*</span>，它就是一个 Generator 函数；特殊一点，如果这个方法名刚好叫<span class='code'>* [Symbol.iterator]</span>，恭喜你，实例化这个类你就过得了一个遍历器，至于具体能遍历出啥来，就看你方法中怎么定义了。</p>

<h2>静态方法</h2>
<p>类语法支持定义静态方法，语法非常符合认知：（两种定义方法都可以）</p>
<img src='/img/illustration/es6-daily/class-static-method.svg' alt=''>
<p>注意，静态方法中的<span class='code'>this</span>指向的是类本身，而不是实例，也就是这里的<span class='code'>this</span>只能访问静态方法和静态变量。</p>
<img src='/img/illustration/es6-daily/class-static-method-this.svg' alt=''>

<h2>静态属性</h2>
<p>ES6 规定类内部只有静态方法，没有静态属性，但后续的提案很快就把这块加上了。当然 ES5 的语法依然有效。</p>
<img src='/img/illustration/es6-daily/class-static-property.svg' alt=''>

<h2>未完待续</h2>
<p>困了，先写到这里，明天继续……</p>
<!-- <h2>小结</h2> -->

<h2>该系列的其他文章</h2>
<p>上一篇：<a href="es6-daily-17-async-await.html">每天一点ES6(17)：Async / Await</a></p>
<p>下一篇：<a href="javascript:;">每天一点ES6(19)：Module</a></p>
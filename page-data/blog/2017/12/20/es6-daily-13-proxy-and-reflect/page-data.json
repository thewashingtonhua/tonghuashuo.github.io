{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/2017/12/20/es6-daily-13-proxy-and-reflect","webpackCompilationHash":"e59d3f6df542cc34ed00","result":{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<h2>写在前面</h2>\n<p>又好久没更了，这次来讲的是 ES6 中比较冷门的一块内容：元编程。大部分时候其实我们不会接触到这一块，日常的业务开发通常不会涉及这么高级的操作，但元编程对于一门语言来说可谓是瑞士军刀，一旦掌握，便可以施展出强大的法力。</p>\n<h2>元编程是个什么鬼？</h2>\n<p>一般我们编程都是为了实现一些业务上的需求，直接使用语言原生提供的内容即可，最多在其上做一层简单的封装。而元编程则是对编程语言本身进行编程，去修改其原本的行为，实现一些原生方法做不到的事，但实际编写起来又是原生的语法，非常神奇。</p>\n<h2>Proxy</h2>\n<p>Proxy 本意是代理，一般我们在计算机网络中经常听到这个词。使用 Proxy 我们可以通过编程来接管外界对对象的操作，改变其原本的行为。有点类似于中间件的概念。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-js line-numbers\"><code class=\"gatsby-code-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">getting </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">setting </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nobj<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token comment\">//  setting count!</span>\n<span class=\"token operator\">++</span>obj<span class=\"token punctuation\">.</span>count\n<span class=\"token comment\">//  getting count!</span>\n<span class=\"token comment\">//  setting count!</span>\n<span class=\"token comment\">//  2</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如上的代码就对对象 obj 的读取和设置操作进行了接管，在其原有行为之前加上了一些内容。</p>\n<p>Proxy 的基本使用为： <code class=\"gatsby-code-text\">const proxy = new Proxy(target, handler)</code> ，target 为被代理的对象，handler 中定义了拦截的行为。</p>\n<p>Proxy 实例可以作为对象的原型：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-js line-numbers\"><code class=\"gatsby-code-js\"><span class=\"token keyword\">var</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">target<span class=\"token punctuation\">,</span> property</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">35</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span>time <span class=\"token comment\">// 35</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这里 obj 本身并没有 time 属性，因此沿原型链向上寻找，找到 proxy 的 time 属性，proxy 虽然也没有 time 属性，但其拦截了所有属性访问操作并固定返回 35，因此依然能拿到结果。</p>\n<h3>Proxy 支持的拦截操作</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>get(target, key, receiver)</td>\n<td>拦截对象属性的读取，三个参数分别为：目标对象、属性名、proxy 实例本身（即 this 所指），其中最后一个参数可选</td>\n</tr>\n<tr>\n<td>set(target, key, value, receiver)</td>\n<td>拦截对象属性的设置，返回布尔值</td>\n</tr>\n<tr>\n<td>has(target, key)</td>\n<td>拦截 <code class=\"gatsby-code-text\">key in obj</code> 的操作，返回布尔值</td>\n</tr>\n<tr>\n<td>deleteProperty(target, key)</td>\n<td>拦截 <code class=\"gatsby-code-text\">delete obj[key]</code> 操作，返回一个布尔值</td>\n</tr>\n<tr>\n<td>ownKeys(target)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.getOwnPropertyNames(obj)</code> 、 <code class=\"gatsby-code-text\">Object.getOwnPropertySymbols(obj)</code> 、 <code class=\"gatsby-code-text\">Object.keys(obj)</code> 操作，返回一个数组，包含目标对象所有自身的属性的属性名。 <code class=\"gatsby-code-text\">Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</td>\n</tr>\n<tr>\n<td>getOwnPropertyDescriptor(target, key)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.getOwnPropertyDescriptor(obj, key)</code> ，返回属性的描述对象</td>\n</tr>\n<tr>\n<td>defineProperty(target, key)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.defineProperty(obj, key, desc)</code> 、 <code class=\"gatsby-code-text\">Object.defineProperties(obj, key, descs)</code> ，返回一个布尔值</td>\n</tr>\n<tr>\n<td>preventExtensions(target)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.preventExtensions(obj)</code> ，返回一个布尔值</td>\n</tr>\n<tr>\n<td>getPrototypeOf(target)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.getPrototypeOf(obj)</code> ，返回一个对象</td>\n</tr>\n<tr>\n<td>isExtensible(target)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.isExtensible(obj)</code> ，返回一个布尔值</td>\n</tr>\n<tr>\n<td>setPrototypeOf(target, prototype)</td>\n<td>拦截 <code class=\"gatsby-code-text\">Object.setPrototypeOf(obj, prototype)</code> ，返回一个布尔值，如果目标对象是函数那么还有两种额外操作可以拦截。</td>\n</tr>\n<tr>\n<td>apply(target, obj, args)</td>\n<td>拦截 Proxy 实例作为函数调用的操作，例如： <code class=\"gatsby-code-text\">proxy(...args)</code> 、 <code class=\"gatsby-code-text\">proxy.call(object, ...args)</code> 、 <code class=\"gatsby-code-text\">proxy.apply(...)</code></td>\n</tr>\n<tr>\n<td>construct(target, args)</td>\n<td>拦截 Proxy 实例作为构造函数调用的操作，例如： <code class=\"gatsby-code-text\">new proxy(...args)</code></td>\n</tr>\n</tbody>\n</table>\n<h3>Proxy.revocable()</h3>\n<p> <code class=\"gatsby-code-text\">Proxy.revocable()</code> 返回一个对象，该对象的 <code class=\"gatsby-code-text\">proxy</code> 属性是 Proxy 实例， <code class=\"gatsby-code-text\">revoke</code>  是一个用于取消 Proxy 实例的函数。被取消的 Proxy 实例不可再被访问。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-js line-numbers\"><code class=\"gatsby-code-js\"><span class=\"token keyword\">let</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> handler <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span>proxy<span class=\"token punctuation\">,</span> revoke<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> Proxy<span class=\"token punctuation\">.</span><span class=\"token function\">revocable</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nproxy<span class=\"token punctuation\">.</span>foo <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token punctuation\">.</span>foo <span class=\"token comment\">// 123</span>\n\n<span class=\"token function\">revoke</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token punctuation\">.</span>foo <span class=\"token comment\">// TypeError: Revoked</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p> <code class=\"gatsby-code-text\">Proxy.revocable()</code> 的一个使用场景就是临时授权对象访问。一个对象不允许直接访问，但允许通过代理临时访问，访问结束后收回代理权，之后不再允许访问。</p>\n<h3>Proxy 中的 this</h3>\n<p>在使用了 Proxy 的情况下，目标对象内部的 <code class=\"gatsby-code-text\">this</code> 关键字会指向 Proxy 代理，而非原本的对象。使用时要时刻注意这一点，Proxy 内部的 <code class=\"gatsby-code-text\">this</code> 未必是我们以为的那一个</p>\n<h2>Reflect</h2>\n<p>字面意思解叫“反射”，熟悉 Java 的朋友应该也有接触过这个词。它和 Proxy 一样，都是 ES6 引入的用于操作对象的新 API。</p>\n<p>Reflect 的设计目的有以下几个：</p>\n<ol>\n<li>将 <code class=\"gatsby-code-text\">Object</code> 中一些明显属于语言内部的方法放到 <code class=\"gatsby-code-text\">Reflect</code> 对象上，例如： <code class=\"gatsby-code-text\">Object.defineProperty</code> 。</li>\n<li>合理化一些 <code class=\"gatsby-code-text\">Object</code> 方法的返回结果，例如： <code class=\"gatsby-code-text\">Object.defineProperty</code> 在无法定义属性是会抛出错误，而 <code class=\"gatsby-code-text\">Reflect.defineProperty</code> 只是返回 <code class=\"gatsby-code-text\">false</code> 。</li>\n<li>让 <code class=\"gatsby-code-text\">Object</code> 中命令式的操作都变成函数式。例如： <code class=\"gatsby-code-text\">key in obj</code> 、 <code class=\"gatsby-code-text\">delete obj[key]</code> 是命令式的， <code class=\"gatsby-code-text\">Reflect.has(obj, key)</code> 、 <code class=\"gatsby-code-text\">Reflect.deleteProperty(obj, key)</code> 就是函数式的。</li>\n<li><code class=\"gatsby-code-text\">Reflect</code> 中的方法与<spanc class='code'>Proxy</spanc>中的一一对应，在 <code class=\"gatsby-code-text\">Proxy</code> 中始终可以通过 <code class=\"gatsby-code-text\">Reflect</code> 获取默认行为。</li>\n</ol>\n<p>简而言之， <code class=\"gatsby-code-text\">Reflect</code> 的存在意义有两点：一是把一些原本捆绑在 <code class=\"gatsby-code-text\">Object</code> 对象上但实际上更应该属于语言内部的方法提取出来，并加以合理化，让 <code class=\"gatsby-code-text\">Object</code> 更纯粹作为一种数据结构。二是和 <code class=\"gatsby-code-text\">Proxy</code> 组 CP，用于在 <code class=\"gatsby-code-text\">Proxy</code> 中始终指向默认行为，防止加了代理之后回不去。</p>\n<h3>Reflect 的静态方法</h3>\n<p>如前面所说的， <code class=\"gatsby-code-text\">Reflect</code> 的静态方法和 <code class=\"gatsby-code-text\">Proxy</code> 支持的拦截操作一一对应。</p>\n<ul>\n<li>Reflect.apply(target, thisArg, args)</li>\n<li>Reflect.construct(target, args)</li>\n<li>Reflect.get(target, name, receiver)</li>\n<li>Reflect.set(target, name, value, receiver)</li>\n<li>Reflect.defineProperty(target, name, desc)</li>\n<li>Reflect.deleteProperty(target, name)</li>\n<li>Reflect.has(target, name)</li>\n<li>Reflect.ownKeys(target)</li>\n<li>Reflect.isExtensible(target)</li>\n<li>Reflect.preventExtensions(target)</li>\n<li>Reflect.getOwnPropertyDescriptor(target, name)</li>\n<li>Reflect.getPrototypeOf(target)</li>\n<li>Reflect.setPrototypeOf(target, prototype)</li>\n</ul>\n<h2>小结</h2>\n<p>通过 Proxy 和 Reflect，我们可以进一步控制对象的行为，甚至改变其默认行为。这可以说是对 JavaScript 能力的又一次提升。</p>\n<h2>该系列的其他文章</h2>\n<p>上一篇：<a href=\"/blog/2017/07/03/es6-daily-12-set-and-map\">每天一点ES6(12)：Map 和 Set</a></p>\n<p>下一篇：<a href=\"/blog/2018/02/28/es6-daily-14-iterator\">每天一点ES6(14)：Iterator</a></p>","frontmatter":{"title":"每天一点ES6(13)：Proxy 和 Reflect","description":"对不起，有代理真就是可以为所欲为","cover":{"publicURL":"/static/es6daily-0950334fb8899f1006423341cbfeecb9.jpg"},"tags":["ecmascript","2015","es6","javascript","proxy","reflect"],"series":"es6daily","draft":false},"fields":{"id":"es6-daily-13-proxy-and-reflect","date":"2017-12-19T16:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2017/12/20/es6-daily-13-proxy-and-reflect"}}}